---
source: tests/src/test_snapshots.rs
assertion_line: 28
expression: result
---
// Note: async/await code - formatting skipped for edition compatibility
# [derive (Default , Debug , Clone , PartialEq , serde :: Serialize , serde :: Deserialize)] # [serde (rename_all = "camelCase")] pub struct User { pub id : f64 , pub name : String , pub email : String , pub is_active : bool }
# [derive (Default , Debug , Clone , PartialEq , serde :: Serialize , serde :: Deserialize)] # [serde (rename_all = "camelCase")] pub struct ApiResponse { pub success : bool , pub data : String , pub timestamp : f64 }
# [derive (Default , Debug , Clone)] struct UserService { pub base_url : std :: sync :: Arc < std :: sync :: Mutex < String >> }
impl UserService { pub fn new (base_url : String) -> Self { Self { base_url : std :: sync :: Arc :: new (std :: sync :: Mutex :: new (base_url)) } } pub fn new_di () -> Self { Self { base_url : std :: sync :: Arc :: new (std :: sync :: Mutex :: new (Default :: default ())) } } pub async fn fetch_user (& mut self , id : f64) -> Result < User , AppError > { return Ok (get_from_database (id) . await ?) ; } pub async fn save_user (& mut self , user : User) -> Result < ApiResponse , AppError > { return Ok (post_to_database (user) . await ?) ; } pub fn get_base_url (& mut self) -> String { return self . base_url . lock () . unwrap () . clone () ; } }
async fn get_from_database (id : f64) -> Result < User , AppError > { return Ok (serde_json :: from_value (serde_json :: json ! ({ "id" : id , "name" : String :: from ("Test User") , "email" : String :: from ("test@example.com") , "isActive" : true })) . unwrap_or_else (| e | panic ! ("Failed to convert return value: {}" , e))) ; }
async fn post_to_database (user : User) -> Result < ApiResponse , AppError > { return Ok (serde_json :: from_value (serde_json :: json ! ({ "success" : true , "data" : user . name , "timestamp" : 1234567890f64 })) . unwrap_or_else (| e | panic ! ("Failed to convert return value: {}" , e))) ; }
fn calculate_total (a : f64 , b : f64 , c : f64) -> f64 { return a + b + c ; }


use axum::{response::{IntoResponse, Response}, http::StatusCode};

#[derive(Debug)]
pub struct AppError(Box<dyn std::error::Error + Send + Sync>);

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            self.0.to_string(),
        )
            .into_response()
    }
}

impl<E> From<E> for AppError
where
    E: std::error::Error + Send + Sync + 'static,
{
    fn from(err: E) -> Self {
        Self(Box::new(err))
    }
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
