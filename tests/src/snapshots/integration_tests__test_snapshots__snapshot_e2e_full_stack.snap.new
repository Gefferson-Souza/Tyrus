---
source: tests/src/test_snapshots.rs
assertion_line: 24
expression: result
---
// Note: async/await code - formatting skipped for edition compatibility
# [derive (Default , Debug , Clone , PartialEq , serde :: Serialize , serde :: Deserialize)] pub struct User { pub id : f64 , pub name : String , pub email : String , pub isActive : bool }
# [derive (Default , Debug , Clone , PartialEq , serde :: Serialize , serde :: Deserialize)] pub struct ApiResponse { pub success : bool , pub data : String , pub timestamp : f64 }
# [derive (Default , Debug , Clone , PartialEq , serde :: Serialize , serde :: Deserialize)] struct UserService { pub baseUrl : String }
impl UserService { pub fn new (baseUrl : String) -> Self { Self { baseUrl : base_url } } pub fn new_di () -> Self { Self { baseUrl : Default :: default () } } pub async fn fetch_user (& mut self , id : f64) -> Result < User , crate :: AppError > { return Ok (get_from_database (id) . await ?) ; } pub async fn save_user (& mut self , user : User) -> Result < ApiResponse , crate :: AppError > { return Ok (post_to_database (user) . await ?) ; } pub fn get_base_url (& mut self) -> String { return self . base_url . clone () ; } }
async fn get_from_database (id : f64) -> Result < User , crate :: AppError > { return Ok (serde_json :: json ! ({ "id" : id , "name" : String :: from ("Test User") , "email" : String :: from ("test@example.com") , "isActive" : todo ! ("unsupported literal") })) ; }
async fn post_to_database (user : User) -> Result < ApiResponse , crate :: AppError > { return Ok (serde_json :: json ! ({ "success" : todo ! ("unsupported literal") , "data" : user . name , "timestamp" : 1234567890f64 })) ; }
fn calculate_total (a : f64 , b : f64 , c : f64) -> f64 { return a + & b + & c ; }
